<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Bitwalker</title>
    <link>http://bitwalker.org/categories/programming/</link>
    <description>Recent content in Programming on Bitwalker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2016 Paul Schoenfelder</copyright>
    <lastBuildDate>Mon, 28 Aug 2017 21:19:00 -0500</lastBuildDate>
    
	<atom:link href="http://bitwalker.org/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using Elixir 1.5&#39;s open command with Emacs.app</title>
      <link>http://bitwalker.org/posts/2017-08-28-open-with-iex-and-emacs/</link>
      <pubDate>Mon, 28 Aug 2017 21:19:00 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2017-08-28-open-with-iex-and-emacs/</guid>
      <description>If you are a user of Emacs, you may have seen Chris McCord&amp;rsquo;s post on the Dockyard blog last week about using Elixir 1.5&amp;rsquo;s new open command in IEx with terminal Emacs.
Being an Emacs user, but preferring Emacs.app generally to the terminal Emacs, I decided to investigate applying his work to my own workflow. I promised to write it up if I succeeded, so here we are!
The first thing we need to do is place some scripts (or symlink them) in /usr/local/bin.</description>
    </item>
    
    <item>
      <title>Elixir/Erlang Clustering in Kubernetes</title>
      <link>http://bitwalker.org/posts/2016-08-04-clustering-in-kubernetes/</link>
      <pubDate>Thu, 04 Aug 2016 18:00:00 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2016-08-04-clustering-in-kubernetes/</guid>
      <description>At work, our infrastructure is run on OpenShift Origin, a RedHat OSS project which is a bunch of nice tooling on top of Kubernetes. It&amp;rsquo;s been really pleasant to work with for the most part, though there have been some growing pains and lessons learned along the way. Since I was responsible for pushing to adopt it, and setting up the cluster, I&amp;rsquo;ve been sort of the go-to for edge cases and advice designing our applications around it.</description>
    </item>
    
    <item>
      <title>Distillery vs. Exrm vs. Relx</title>
      <link>http://bitwalker.org/posts/2016-07-21-distillery-vs-exrm-vs-relx/</link>
      <pubDate>Thu, 21 Jul 2016 17:48:07 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2016-07-21-distillery-vs-exrm-vs-relx/</guid>
      <description>I received an excellent question on Twitter today:
Can you explain the different ideas/approaches of distillery/exrm and relx? Maybe even edeliver? What prompted the rewrite? ðŸ™‚
&amp;mdash; Felipe Sere (@felipesere) July 21, 2016  I&amp;rsquo;ve been focusing more on implementing Distillery, sharing it with people willing to help test, etc., that I forgot to sit down and write down why it exists in the first place. So in this post, I&amp;rsquo;ll attempt to explain as best I can.</description>
    </item>
    
    <item>
      <title>Proxied Streaming Uploads with Scala/Play</title>
      <link>http://bitwalker.org/posts/2014-07-10-scala-streaming-file-uploads/</link>
      <pubDate>Thu, 10 Jul 2014 10:30:05 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2014-07-10-scala-streaming-file-uploads/</guid>
      <description>I recently was working on a project using a mashup of technologies: Scala, Play Framework, Sqrrl/Accumulo, Microsoft SQL Server, Hadoop/HDFS, Hive, and some others. Needless to say, rampup was a bit like swallowing water from a firehose. I was brought on to help get a release completed by it&amp;rsquo;s deadline, so I wasn&amp;rsquo;t on the project for more than a month, but I did encounter one very fun problem that I felt like sharing.</description>
    </item>
    
    <item>
      <title>Releases For Elixir</title>
      <link>http://bitwalker.org/posts/2014-03-11-releases-for-elixir/</link>
      <pubDate>Thu, 20 Mar 2014 01:00:00 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2014-03-11-releases-for-elixir/</guid>
      <description>Be forewarned, this post requires a fair amount of knowledge about Elixir or Erlang. Though the topic of hot code upgrades and downgrades is probably of interest to any dev who crosses the line in to ops on a regular basis, this particular post is going to be diving headlong into the madness that is Erlang releases, and how I&amp;rsquo;ve fixed them for Elixir.
I was hanging out in #elixir-lang last week, when someone (I believe it was tylerflint) brought up the issue of performing releases with Elixir.</description>
    </item>
    
    <item>
      <title>Learn by Example: Scala Parser Combinators</title>
      <link>http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators/</link>
      <pubDate>Sat, 10 Aug 2013 22:28:00 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators/</guid>
      <description>One of the more common things you run into during software development is the need to parse arbitrary text for data. Typically, you might use regular expressions, or encode assumptions about the data format in the way you parse the text (think slicing a string at specific indices, splitting on commas, etc). Both of these are brittle, and require a lot of verbose code to properly handle all of the possible failure points.</description>
    </item>
    
  </channel>
</rss>