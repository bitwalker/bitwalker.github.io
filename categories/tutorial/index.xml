<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on Bitwalker</title>
    <link>http://bitwalker.org/categories/tutorial/</link>
    <description>Recent content in Tutorial on Bitwalker</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>2016 Paul Schoenfelder</copyright>
    <lastBuildDate>Sat, 10 Aug 2013 22:28:00 -0500</lastBuildDate>
    
	<atom:link href="http://bitwalker.org/categories/tutorial/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Learn by Example: Scala Parser Combinators</title>
      <link>http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators/</link>
      <pubDate>Sat, 10 Aug 2013 22:28:00 -0500</pubDate>
      
      <guid>http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators/</guid>
      <description>One of the more common things you run into during software development is the need to parse arbitrary text for data. Typically, you might use regular expressions, or encode assumptions about the data format in the way you parse the text (think slicing a string at specific indices, splitting on commas, etc). Both of these are brittle, and require a lot of verbose code to properly handle all of the possible failure points.</description>
    </item>
    
  </channel>
</rss>