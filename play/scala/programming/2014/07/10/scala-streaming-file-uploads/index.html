<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Proxied Streaming Uploads with Scala/Play &#8211; bitwalker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Stuff about things.">
    <meta name="author" content="Paul Schoenfelder">
    <meta name="keywords" content="play, scala, programming">
    <link rel="canonical" href="/play/scala/programming/2014/07/10/scala-streaming-file-uploads/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for bitwalker" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201507160346" type="text/css">

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    


    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Proxied Streaming Uploads with Scala/Play">
    <meta property="og:description" content="Stuff about things.">
    <meta property="og:url" content="/play/scala/programming/2014/07/10/scala-streaming-file-uploads/">
    <meta property="og:site_name" content="bitwalker">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@gotbones" />
    
    <meta name="twitter:title" content="Proxied Streaming Uploads with Scala/Play" />
    <meta name="twitter:description" content="Stuff about things." />
    <meta name="twitter:url" content="/play/scala/programming/2014/07/10/scala-streaming-file-uploads/" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
        
    
</head>

<body class="site">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="" class="site-title">bitwalker</a>
      <nav class="site-nav">
        <a href="/about/">About</a>

      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Proxied Streaming Uploads with Scala/Play</h1>
  <span class="post-meta">Jul 10, 2014</span><br>
    
  <span class="post-meta small">
  
    28 minute read
  
  </span>
</div>

<article class="post-content">
  <p>I recently was working on a project using a mashup of technologies: Scala, Play Framework, Sqrrl/Accumulo, Microsoft SQL Server, Hadoop/HDFS, Hive, and some others. Needless to say, rampup was a bit like swallowing water from a firehose. I was brought on to help get a release completed by it’s deadline, so I wasn’t on the project for more than a month, but I did encounter one very fun problem that I felt like sharing. To briefly summarize the context: The project was composed of two Play applications, a web frontend, which served up the assets for the UI and handled proxying requests to the API, which was behind a firewall, and therefore not accessible from the internet. Users needed to be able to upload files containing potentially sensitive data, of varying types, and of unrestricted size (though I would guess the average file size would hover between 25-100mb). These files were ultimately stored in HDFS, behind yet another firewall, which is only accessible by the API server. Not your average file upload scenario.</p>

<!-- more -->

<h2 id="the-scenario">The Scenario</h2>

<p>So the requirements are as follows:</p>

<ul>
  <li>Files cannot be stored on the web or API server (potential security risk)</li>
  <li>Files should not be stored in memory during uploads, due to the combination of large file sizes and potential for large amounts of concurrent uploads consuming too much of the servers memory.</li>
  <li>The final destination of the files is HDFS.</li>
  <li>Files also need to be downloadable, with the same constraints</li>
</ul>

<p>My final solution was the following:</p>

<ul>
  <li>Write a custom streaming body parser for streaming uploads from the client straight to the API server</li>
  <li>Write a custom streaming body parser for streaming uploads from the web server directly to HDFS</li>
  <li>Use Apache Tika to detect content type of the upload, and store that with other metadata in SQL</li>
  <li>When a download of a file is requested, use a custom iteratee from the web server to stream the chunked response data  from the API, straight to the client, while preserving the response headers containing file metadata.</li>
</ul>

<p>What initially seemed relatively straight forward, turned out to be one of the most complex but interesting bits of code I’ve written in quite some time. There’s a lot of code coming, because I’d like to share the entire solution (with project-specific bits stripped out), so buckle up.</p>

<h2 id="stage-1---client---web">Stage 1 - Client -&gt; Web</h2>

<p>Let’s begin with the first stage of the upload process, streaming files from the client to the API, via the web application. First, we have our controller:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">controllers</span>

<span class="k">import</span> <span class="nn">play.api.mvc._</span>
<span class="k">import</span> <span class="nn">controllers.traits.Secured</span>
<span class="k">import</span> <span class="nn">util.parsers.StreamingBodyParser._</span>

<span class="k">object</span> <span class="nc">ApiProxyController</span> <span class="k">extends</span> <span class="nc">Controller</span> <span class="k">with</span> <span class="nc">Secured</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">makeFileUploadRequest</span><span class="o">(</span><span class="n">endpointPath</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">AuthenticatedAction</span><span class="o">(</span><span class="n">streamingBodyParser</span><span class="o">(</span><span class="n">endpointPath</span><span class="o">))</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">request</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">uploadResult</span> <span class="k">=</span> <span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">files</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">ref</span>
      <span class="n">uploadResult</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span>
        <span class="n">err</span>     <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="n">errorMessage</span><span class="o">),</span>
        <span class="n">success</span> <span class="k">=&gt;</span> <span class="nc">Ok</span><span class="o">(</span><span class="n">success</span><span class="o">.</span><span class="n">body</span><span class="o">)</span>
      <span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span></code></pre></div>

<p>The only things to note here are that we do user authentication at this point, using a custom action, which takes an implementation of <code>BodyParser</code>. The custom streaming body parser needs to know the endpoint we’re sending the file to, so we use a partially applied constructor function in order to provide that information. The body of the action here is executed once parsing of the body has completed, so all we have to do at that point is check the result of the upload, which in this case is an instance of <code>Either[StreamingError, StreamingSuccess]</code>.</p>

<p>Next, we have our custom streaming body parser. This is a big one, so I’m going to use comments in the code to describe notable features instead of showing you code and then talking about it. I’ll summarize some things before moving on though.</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">util.parsers</span>

<span class="k">import</span> <span class="nn">play.api.mvc.</span><span class="o">{</span><span class="nc">BodyParser</span><span class="o">,</span> <span class="nc">RequestHeader</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">play.api.mvc.BodyParsers.parse</span>
<span class="k">import</span> <span class="nn">parse.Multipart.PartHandler</span>
<span class="k">import</span> <span class="nn">play.api.mvc.MultipartFormData.FilePart</span>
<span class="k">import</span> <span class="nn">java.io.</span><span class="o">{</span><span class="nc">PrintWriter</span><span class="o">,</span> <span class="nc">OutputStreamWriter</span><span class="o">,</span> <span class="nc">OutputStream</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">java.net.</span><span class="o">{</span><span class="nc">URL</span><span class="o">,</span> <span class="nc">URLConnection</span><span class="o">,</span> <span class="nc">HttpURLConnection</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">play.api.libs.iteratee.</span><span class="o">{</span><span class="nc">Cont</span><span class="o">,</span> <span class="nc">Done</span><span class="o">,</span> <span class="nc">Input</span><span class="o">,</span> <span class="nc">Iteratee</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">models.</span><span class="o">{</span><span class="nc">ApiRequest</span><span class="o">,</span> <span class="nc">AuthUser</span><span class="o">}</span>

<span class="cm">/**
 * These two classes represent the success or failure result of the upload,
 * if it succeeded, StreamingSuccess.body will contain the response body from
 * the API. If it fails, StreamingError.errorMessage will contain the error message
 * received in the response body.
 */</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">StreamingSuccess</span><span class="o">(</span><span class="n">body</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">StreamingError</span><span class="o">(</span><span class="n">errorMessage</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="cm">/**
 * This companion object contains the constructor for our custom BodyParser,
 * as well as the logic for constructing the output stream to the API.
 */</span>
<span class="k">object</span> <span class="nc">StreamingBodyParser</span> <span class="o">{</span>
  <span class="cm">/**
   * If you recall, we partially apply the API endpoint path in the controller when providing
   * the request body parser to use. In turn, the action will invoke the partial function
   * when it begins parsing the request.
   */</span>
  <span class="k">def</span> <span class="n">streamingBodyParser</span><span class="o">(</span><span class="n">endpointPath</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">BodyParser</span> <span class="o">{</span> <span class="n">request</span> <span class="k">=&gt;</span>
    <span class="c1">// Use Play's built in multipart/form-data parser, with our own FilePartHandler.
</span>    <span class="c1">// Essentially, Play will handle parsing the normal form data, we'll handle parsing the file
</span>    <span class="n">parse</span><span class="o">.</span><span class="n">multipartFormData</span><span class="o">(</span><span class="k">new</span> <span class="nc">StreamingBodyParser</span><span class="o">(</span><span class="n">streamConstructor</span><span class="o">(</span><span class="n">endpointPath</span><span class="o">,</span> <span class="n">request</span><span class="o">))</span>
      <span class="o">.</span><span class="n">streamingFilePartHandler</span><span class="o">(</span><span class="n">request</span><span class="o">))</span>
      <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="cm">/**
   * This function constructs an HttpURLConnection object to the provided endpoint path,
   * with the necessary authentication headers, as well as headers to setup the chunked
   * streaming mode. As you may have noticed, it's intended to be partially applied by
   * first providing the endpoint path and request object, then invoking the resulting
   * function when we want to produce the connection object.
   */</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">streamConstructor</span><span class="o">(</span><span class="n">endpointPath</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">request</span><span class="k">:</span> <span class="kt">RequestHeader</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">HttpURLConnection</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// This is a bit of project-specific logic, but basically we're validating
</span>    <span class="c1">// that the request is authenticated before opening the request to the API
</span>    <span class="nc">AuthUser</span><span class="o">.</span><span class="n">buildFromSession</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="n">session</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="c1">// Again, internals, all we're doing here is building the authentication headers,
</span>        <span class="c1">// for example, Authorization, with the API token for the user
</span>        <span class="k">val</span> <span class="n">headers</span> <span class="k">=</span> <span class="nc">ApiRequest</span><span class="o">.</span><span class="n">buildRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">authToken</span><span class="o">).</span><span class="n">buildHeaders</span>

        <span class="c1">// Construct the request connection to the API. It will always be a POST, with
</span>        <span class="c1">// chunked streaming mode enabled, with 1mb chunks, with output enabled
</span>        <span class="k">val</span> <span class="n">url</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="nc">Global</span><span class="o">.</span><span class="nc">API_ENDPOINT</span> <span class="o">+</span> <span class="n">endpointPath</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">con</span> <span class="k">=</span> <span class="n">url</span><span class="o">.</span><span class="n">openConnection</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">HttpURLConnection</span><span class="o">]</span>
        <span class="n">con</span><span class="o">.</span><span class="n">setRequestMethod</span><span class="o">(</span><span class="s">"POST"</span><span class="o">)</span>
        <span class="n">con</span><span class="o">.</span><span class="n">setChunkedStreamingMode</span><span class="o">(</span><span class="mi">1024</span><span class="o">)</span>
        <span class="n">con</span><span class="o">.</span><span class="n">setDoOutput</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>

        <span class="c1">// Set auth headers
</span>        <span class="n">headers</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">header</span> <span class="k">=&gt;</span>
          <span class="n">con</span><span class="o">.</span><span class="n">setRequestProperty</span><span class="o">(</span><span class="n">header</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">header</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
        <span class="o">}</span>

        <span class="c1">// Pass along request headers
</span>        <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">toSimpleMap</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">h</span> <span class="k">=&gt;</span> <span class="n">con</span><span class="o">.</span><span class="n">setRequestProperty</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">h</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>

        <span class="nc">Some</span><span class="o">(</span><span class="n">con</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>

<span class="c1">// Our custom BodyParser's constructor takes a function which produces an HttpURLConnection.
</span><span class="k">class</span> <span class="nc">StreamingBodyParser</span><span class="o">(</span><span class="n">streamConstructor</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">HttpURLConnection</span><span class="o">])</span> <span class="o">{</span>

  <span class="cm">/**
   * This "handler" function actually produces a function which is the
   * actual handler executed by Play when parsing files in the request.
   */</span>
  <span class="k">def</span> <span class="n">streamingFilePartHandler</span><span class="o">(</span><span class="n">request</span><span class="k">:</span> <span class="kt">RequestHeader</span><span class="o">)</span><span class="k">:</span>
          <span class="kt">PartHandler</span><span class="o">[</span><span class="kt">FilePart</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">StreamingError</span>, <span class="kt">StreamingSuccess</span><span class="o">]]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// An execution context is required for the Iteratee below
</span>    <span class="k">import</span> <span class="nn">play.api.libs.concurrent.Execution.Implicits._</span>

    <span class="k">val</span> <span class="nc">CRLF</span> <span class="k">=</span> <span class="s">"\r\n"</span>

    <span class="c1">// This produces the PartHandler function which is consumed by Play's
</span>    <span class="c1">// multipartFormData body parser.
</span>    <span class="n">parse</span><span class="o">.</span><span class="nc">Multipart</span><span class="o">.</span><span class="n">handleFilePart</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">parse</span><span class="o">.</span><span class="nc">Multipart</span><span class="o">.</span><span class="nc">FileInfo</span><span class="o">(</span><span class="n">partName</span><span class="o">,</span> <span class="n">filename</span><span class="o">,</span> <span class="n">contentType</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="c1">// Reference to hold the error message if one is produced
</span>        <span class="k">var</span> <span class="n">errorMsg</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">StreamingError</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

        <span class="c1">// Get the HTTP connection to the API
</span>        <span class="k">val</span> <span class="n">connection</span> <span class="k">=</span> <span class="n">streamConstructor</span><span class="o">(</span><span class="n">filename</span><span class="o">).</span><span class="n">get</span>

        <span class="c1">// Set content-type property for the API request
</span>        <span class="k">val</span> <span class="n">boundary</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">().</span><span class="n">toHexString</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">setRequestProperty</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"multipart/form-data; boundary="</span> <span class="o">+</span> <span class="n">boundary</span><span class="o">)</span>

        <span class="cm">/**
         * Create the output stream. If something goes wrong while trying to instantiate
         * the output stream, assign the error message to the result reference, e.g.
         *    `result = Some(StreamingError("network error"))`
         * and set the outputStream reference to `None`; the `Iteratee` will then do nothing
         * and the error message will be passed to the `Action`.
         */</span>
        <span class="k">val</span> <span class="n">outputStream</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">OutputStream</span><span class="o">]</span> <span class="k">=</span> <span class="k">try</span> <span class="o">{</span>
          <span class="nc">Some</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">getOutputStream</span><span class="o">())</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span> <span class="o">{</span>
            <span class="n">errorMsg</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">StreamingError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">getMessage</span><span class="o">))</span>
            <span class="nc">None</span>
          <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// Create print writer for writing out multipart form data
</span>        <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="n">outputStream</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">os</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">pw</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">os</span><span class="o">))</span>
            <span class="k">val</span> <span class="n">charset</span> <span class="k">=</span> <span class="s">"UTF-8"</span>
            <span class="c1">// Send form parameters.
</span>            <span class="n">request</span><span class="o">.</span><span class="n">queryString</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">queryStrings</span> <span class="k">=&gt;</span>
              <span class="n">pw</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"--"</span> <span class="o">+</span> <span class="n">boundary</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"Content-Disposition: form-data; name=\""</span> <span class="o">+</span> <span class="n">queryStrings</span><span class="o">.</span><span class="n">_1</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">s</span><span class="s">"Content-Type: text/plain; charset=$charset"</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">).</span><span class="n">append</span><span class="o">(</span><span class="n">queryStrings</span><span class="o">.</span><span class="n">_2</span><span class="o">.</span><span class="n">mkString</span><span class="o">)</span>
                <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
                <span class="o">.</span><span class="n">flush</span><span class="o">()</span>
            <span class="o">}</span>

            <span class="c1">// Send binary file header
</span>            <span class="n">pw</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"--"</span> <span class="o">+</span> <span class="n">boundary</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"Content-Disposition: form-data; name=\"file\"; filename=\""</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s">"\""</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">fileType</span> <span class="k">=</span> <span class="nc">URLConnection</span><span class="o">.</span><span class="n">guessContentTypeFromName</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
            <span class="n">pw</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"Content-Type: "</span> <span class="o">+</span> <span class="n">contentType</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">fileType</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"Content-Transfer-Encoding: binary"</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
              <span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">)</span>
              <span class="o">.</span><span class="n">flush</span><span class="o">()</span>
            <span class="nc">Some</span><span class="o">(</span><span class="n">pw</span><span class="o">)</span>
          <span class="o">}</span>
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">None</span>
        <span class="o">}</span>

        <span class="cm">/**
         * This is the interesting bit. This fold function pumps file data from
         * the input stream to the output stream in chunks. Each step will receive
         * one of the Input types, which determines whether we are done parsing, should
         * skip the current chunk (Empty), or call the parser on the chunk before
         * continuing. You can think of this as a reduce operation on the input
         * stream, using the output stream as the accumulator, where each reduction
         * pushes the chunk of data received from the input stream to the output stream.
         */</span>
        <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">state</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">E</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Iteratee</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
          <span class="k">def</span> <span class="n">step</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Iteratee</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">i</span> <span class="k">match</span> <span class="o">{</span>
            <span class="c1">// Hit EOF, we're done parsing
</span>            <span class="k">case</span> <span class="nc">Input</span><span class="o">.</span><span class="nc">EOF</span>   <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Input</span><span class="o">.</span><span class="nc">EOF</span><span class="o">)</span>
            <span class="c1">// If the chunk is empty, skip this chunk and continue
</span>            <span class="k">case</span> <span class="nc">Input</span><span class="o">.</span><span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">step</span><span class="o">(</span><span class="n">s</span><span class="o">)(</span><span class="n">i</span><span class="o">))</span>
            <span class="c1">// We have a non-empty chunk, so call our parser function `f` with the data.
</span>            <span class="k">case</span> <span class="nc">Input</span><span class="o">.</span><span class="nc">El</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
              <span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
              <span class="c1">// if an error occurred, set Iteratee to Done
</span>              <span class="n">errorMsg</span> <span class="k">match</span> <span class="o">{</span>
                <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Input</span><span class="o">.</span><span class="nc">EOF</span><span class="o">)</span>
                <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">step</span><span class="o">(</span><span class="n">s1</span><span class="o">)(</span><span class="n">i</span><span class="o">))</span>
              <span class="o">}</span>
            <span class="o">}</span>
          <span class="o">}</span>
          <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">step</span><span class="o">(</span><span class="n">state</span><span class="o">)(</span><span class="n">i</span><span class="o">))</span>
        <span class="o">}</span>

        <span class="cm">/**
         * And here is where we make use of the fold function from above. We
         * give it the output stream as it's accumulator, and a callback function which
         * takes two parameters, the current state of the Iteratee (the output stream)
         * and the data to parse, which will be a byte array. This produces an Iteratee,
         * which will eventually produce Option[OutputStream] as it's result. We map over
         * the Iteratee (called when the Iteratee is finished executing) in order to clean
         * up the resources used, write out the last bit of form data, and get the response
         * from the API.
         */</span>
        <span class="n">fold</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">OutputStream</span><span class="o">]](</span><span class="n">outputStream</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">os</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">os</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">write</span><span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">}</span>
          <span class="n">os</span>
        <span class="o">}.</span><span class="n">map</span> <span class="o">{</span> <span class="n">os</span> <span class="k">=&gt;</span>
          <span class="c1">// Flush the output stream
</span>          <span class="n">os</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">flush</span> <span class="o">}</span>
          <span class="c1">// Write out the end of the multipart form-data
</span>          <span class="n">writer</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">w</span> <span class="k">=&gt;</span>
            <span class="n">w</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">).</span><span class="n">flush</span>
            <span class="n">w</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="s">"--"</span> <span class="o">+</span> <span class="n">boundary</span> <span class="o">+</span> <span class="s">"--"</span><span class="o">).</span><span class="n">append</span><span class="o">(</span><span class="nc">CRLF</span><span class="o">).</span><span class="n">flush</span>
          <span class="o">}</span>
          <span class="c1">// Close the stream and return the final result
</span>          <span class="n">os</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">close</span> <span class="o">}</span>
          <span class="n">errorMsg</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
              <span class="c1">// Check the result for errors
</span>              <span class="k">val</span> <span class="n">responseCode</span> <span class="k">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">getResponseCode</span>
              <span class="k">if</span> <span class="o">(</span><span class="mi">400</span> <span class="o">&lt;=</span> <span class="n">responseCode</span> <span class="o">&amp;&amp;</span> <span class="n">responseCode</span> <span class="o">&lt;</span> <span class="mi">600</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">val</span> <span class="n">errorResponse</span> <span class="k">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">getErrorStream</span>
                <span class="k">val</span> <span class="n">error</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">Source</span><span class="o">.</span><span class="n">fromInputStream</span><span class="o">(</span><span class="n">errorResponse</span><span class="o">).</span><span class="n">mkString</span>
                <span class="nc">Left</span><span class="o">(</span><span class="nc">StreamingError</span><span class="o">(</span><span class="n">s</span><span class="s">"$responseCode: $error"</span><span class="o">))</span>
              <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">val</span> <span class="n">responseStream</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">Source</span><span class="o">.</span><span class="n">fromInputStream</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="n">getInputStream</span><span class="o">)</span>
                <span class="nc">Right</span><span class="o">(</span><span class="nc">StreamingSuccess</span><span class="o">(</span><span class="n">responseStream</span><span class="o">.</span><span class="n">mkString</span><span class="o">))</span>
              <span class="o">}</span>
          <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>So hopefully I haven’t lost you. Just to recap, we’re using a custom BodyParser in order to provide our own FilePartHandler. The former is required for any controller action in a Play application in order to properly parse the request body, the latter is used specifically in multipart/form-data requests to handle binary file data. The FilePartHandler uses iteratees to handle each FilePart (chunk of data, usually a byte array). Iteratees are a method for sequentially processing input data with accumulated state. In the case above, the accumulated state will always be the output stream, because at each step of the sequence, we’re just pushing the data in to the output stream. Another way of thinking about it is to consider the output stream a type of collection. If instead of an output stream, we had used an array, when the iteratee finished executing, we’d have a byte array of the file data instead of an output stream.</p>

<p>So at this point we’ve received a request to upload a file from the user, authenticated them, opened a proxied request to the API, and started pumping file data through. It’s about to get even more fun :)</p>

<h2 id="stage-2---web---api">Stage 2 - Web -&gt; API</h2>

<p>The next step is receiving the request from the web server to the API. From the perspective of the API server, the request is no different than if it came from a browser. Again we’ll have a custom BodyParser, one which is different enough that I’ll show the code for it as well, but I’ll strip out any duplicate information. A key difference here is that the API is not proxying the request to another web server (at least from it’s perspective). Instead, it contains an abstraction around how it stores uploads. This abstraction is defined via the StorageProvider trait, which is injected at runtime with either a local file storage provider, or an HDFS provider. I’m not going to show the concrete implementations of these providers, since they are pretty straightforward, but I will show you the trait, since it’s key to understanding how we’ve abstracted away the concept of storage within the API.</p>

<p>Let’s start with the StorageProvider trait:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">util.storage</span>

<span class="k">import</span> <span class="nn">config.ConfigFactory</span>
<span class="k">import</span> <span class="nn">play.api.libs.iteratee.Enumerator</span>

<span class="k">trait</span> <span class="nc">StorageProvider</span> <span class="k">extends</span> <span class="nc">ConfigFactory</span> <span class="o">{</span>

  <span class="cm">/**
   * Write a file to storage
   * @param data The byte data to write
   * @param fileName The name of the file once stored
   */</span>
  <span class="k">def</span> <span class="n">writeFile</span><span class="o">(</span><span class="n">data</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="cm">/**
   * Gets a stream to the provided filename which can be written to
   * @param fileName The name of the file to stream data to
   */</span>
  <span class="k">def</span> <span class="n">getWriteableStream</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StreamableResource</span>

  <span class="cm">/**
   * Read a file and return it in an Array[Byte].
   * @param fileName The name of the file to read
   * @return
   */</span>
  <span class="k">def</span> <span class="n">readFile</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>

  <span class="cm">/**
   * Given a filename, produce an Enumerator[Array[Byte]] for streaming the file to the consumer
   * @param fileName The name of the file to stream
   * @return
   */</span>
  <span class="k">def</span> <span class="n">getReadableStream</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Enumerator</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]]</span>

  <span class="cm">/**
   * Delete a file from storage
   * @param fileName The name of the file to delete
   */</span>
  <span class="k">def</span> <span class="n">deleteFile</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="cm">/**
   * Detect a given file's content type
   * Uses a combination of reading markers in the file's header,
   * as well as taking the extension into account if markers aren't
   * enough. Returns application/octet-stream if no type can be determined
   * @param fileName
   * @return
   */</span>
  <span class="k">def</span> <span class="n">getFileType</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span></code></pre></div>

<p>Nothing special there, pretty much just an abstraction around typical file operations we all use day to day. As long as your implementation has the ability to open input/output streams, and read/write/delete files, you can store files however you want.</p>

<p>Next up, you’ll need to know about this small class, <code>StreamableResource</code>:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">StreamableResource</span><span class="o">(</span><span class="n">stream</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">OutputStream</span><span class="o">],</span> <span class="n">resource</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Closeable</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Closeable</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">close</span> <span class="k">=</span> <span class="n">resource</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">close</span><span class="o">)</span>
<span class="o">}</span></code></pre></div>

<p>This exists because a StorageProvider implementation likely has a resource connected to the open stream, which will need to be properly cleaned up when streaming is complete.</p>

<p>Alright, let’s dig in to the controller!</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">controllers</span>

<span class="k">import</span> <span class="nn">util.storage.StorageProvider</span>
<span class="k">import</span> <span class="nn">util.controller.ApiSecuredController</span>
<span class="k">import</span> <span class="nn">play.api.mvc._</span>
<span class="k">import</span> <span class="nn">javax.inject.</span><span class="o">{</span><span class="nc">Inject</span><span class="o">,</span> <span class="nc">Singleton</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">providers._</span>
<span class="k">import</span> <span class="nn">play.api.Logger</span>
<span class="k">import</span> <span class="nn">util.parsers.StreamingBodyParser._</span>

<span class="nd">@Singleton</span>
<span class="k">class</span> <span class="nc">ApiController</span> <span class="nd">@Inject</span><span class="o">()(</span>
  <span class="n">fileProvider</span><span class="k">:</span>    <span class="kt">FileProvider</span><span class="o">,</span>
  <span class="n">storageProvider</span><span class="k">:</span> <span class="kt">StorageProvider</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Controller</span> <span class="k">with</span> <span class="nc">ApiSecuredController</span> <span class="o">{</span>

  <span class="cm">/**
   * Similarly to before, e're creating a new instance of our custom BodyParser, which takes
   * a function receiving a StorageProvider, and producing a StreamableResource
   */</span>
  <span class="k">def</span> <span class="n">uploadFile</span><span class="o">()</span> <span class="k">=</span> <span class="nc">Action</span><span class="o">(</span><span class="n">streamingBodyParser</span><span class="o">(</span><span class="n">streamConstructor</span><span class="o">(</span><span class="n">storageProvider</span><span class="o">)))</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">request</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// Act on the result of parsing/storing the uploaded file
</span>      <span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">files</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">ref</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span>
        <span class="c1">// Parsing/storing failed
</span>        <span class="n">err</span>     <span class="k">=&gt;</span> <span class="nc">BadRequest</span><span class="o">(</span><span class="n">err</span><span class="o">.</span><span class="n">errorMessage</span><span class="o">),</span>
        <span class="c1">// Parsing/storing succeeded
</span>        <span class="n">success</span> <span class="k">=&gt;</span> <span class="o">{</span>
          <span class="c1">// If you need access to the form parameters...
</span>          <span class="k">val</span> <span class="n">params</span> <span class="k">=</span> <span class="n">request</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">asFormUrlEncoded</span>
          <span class="c1">// Save metadata record for file
</span>          <span class="k">try</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">contentType</span> <span class="k">=</span> <span class="n">storageProvider</span><span class="o">.</span><span class="n">getFileType</span><span class="o">(</span><span class="n">success</span><span class="o">.</span><span class="n">filename</span><span class="o">)</span>
            <span class="k">val</span> <span class="n">metadata</span>    <span class="k">=</span> <span class="n">fileProvider</span><span class="o">.</span><span class="n">createFile</span><span class="o">(</span><span class="n">contentType</span><span class="o">,</span> <span class="n">success</span><span class="o">.</span><span class="n">filename</span><span class="o">)</span>
            <span class="nc">Ok</span><span class="o">(</span><span class="nc">Json</span><span class="o">.</span><span class="n">toJson</span><span class="o">(</span><span class="n">metadata</span><span class="o">.</span><span class="n">id</span><span class="o">))</span>
          <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
              <span class="nc">Logger</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">"Failed to create file: ${e.getMessage}"</span><span class="o">)</span>
              <span class="nc">BadRequest</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">getMessage</span><span class="o">)</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>And now for the API’s custom body parser:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">StreamingBodyParser</span> <span class="o">{</span>
  <span class="cm">/**
   * The main difference here is that we are generating our output stream differently than in the
   * web project.
  def streamingBodyParser(getStream: String =&gt; Option[StreamableResource]) = BodyParser { request =&gt;
    parse.multipartFormData(new StreamingBodyParser(getStream).streamingFilePartHandler(request))
      .apply(request)
  }

  /**
   * Here is where that difference is implemented. Our stream constructor takes a StorageProvider instance, and
   * returns a function that when called with a filename, will open an output stream to that file, and return it
   * wrapped as a StreamableResource.
   */
  def streamConstructor(storageProvider: StorageProvider)(filename: String): Option[StreamableResource] = {
    Some(storageProvider.getWriteableStream(filename))
  }
}

class StreamingBodyParser(streamConstructor: String =&gt; Option[StreamableResource]) {

  def streamingFilePartHandler(request: RequestHeader):
        PartHandler[FilePart[Either[StreamingError, StreamingSuccess]]] = {
    /**
     * Most of the following is either the same or similar to the web project's
     * implementation, I'll highlight the important changes with comments.
     */
    import play.api.libs.concurrent.Execution.Implicits._

    parse.Multipart.handleFilePart {
      case parse.Multipart.FileInfo(partName, filename, contentType) =&gt;

        // Get StreamableResource by invoking streamConstructor
        // Get output stream from StreamableResource
        // Define fold function, same as before

        /**
         * This is almost identical to the web implementation, but
         * closes the StreamableResource as well as the output stream.
         * It also doesn't need to read any kind of response, so there's
         * a lot less going on.
         */
        fold[Array[Byte], Option[OutputStream]](outputStream) { (os, data) =&gt;
          os foreach { _.write(data) }
          os
        }.map { os =&gt;
          os foreach { _.close }
          streamResource foreach { _.close }
          errorMsg match {
            case Some(result) =&gt;
              // Failed
              Left(result)
            case None =&gt;
              // Succeeded
              Right(StreamingSuccess(filename))
          }
        }
    }
  }
}</span></code></pre></div>

<p>So the above closes the loop on our file upload process. The client makes a request to the web server, the request body is read in chunks and piped via a new request to the API server, the API server reads the request body in chunks, and pipes that data via the storage provider to it’s final destination. During the whole process, the file itself is never stored in memory.</p>

<p>What about downloads though? Let’s take a look:</p>

<h2 id="downloading-files">Downloading Files</h2>

<p>Let’s start with the API controller action first on this one, since it’s the simplest:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="cm">/**
 * As you may have noticed in the upload portion, we're storing file metadata
 * in the database, and returning the ID to the client. That is the id used in
 * this request.
 */</span>
<span class="k">def</span> <span class="n">downloadFile</span><span class="o">(</span><span class="n">fileId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Action</span><span class="o">(</span><span class="n">parse</span><span class="o">.</span><span class="n">anyContent</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">request</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">fileProvider</span><span class="o">.</span><span class="n">getFile</span><span class="o">(</span><span class="n">fileId</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="cm">/**
         * Nothing to crazy here, we're telling Play to stream the
         * response body, using the stream provided by the storage provider,
         * and ensuring that the content-type header is set properly
         */</span>
        <span class="nc">SimpleResult</span><span class="o">(</span>
          <span class="n">header</span> <span class="k">=</span> <span class="nc">ResponseHeader</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="nc">CONTENT_TYPE</span> <span class="o">-&gt;</span> <span class="n">file</span><span class="o">.</span><span class="n">fileType</span><span class="o">)),</span>
          <span class="n">body</span> <span class="k">=</span> <span class="n">storageProvider</span><span class="o">.</span><span class="n">getReadableStream</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">fileName</span><span class="o">)</span>
        <span class="o">)</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="nc">NotFound</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>The interesting bit is here in the web project’s controller action:</p>

<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">makeFileDownloadRequest</span><span class="o">(</span><span class="n">endpointPath</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">AuthenticatedAction</span><span class="o">(</span><span class="n">parse</span><span class="o">.</span><span class="n">anyContent</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">request</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">play.api.libs.concurrent.Execution.Implicits._</span>
    <span class="k">import</span> <span class="nn">play.api.libs.iteratee.</span><span class="o">{</span><span class="nc">Input</span><span class="o">,</span> <span class="nc">Iteratee</span><span class="o">}</span>
    <span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="n">promise</span><span class="o">,</span> <span class="nc">Await</span><span class="o">}</span>
    <span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

    <span class="c1">// First we have to create a new request, containing all the required headers
</span>    <span class="k">val</span> <span class="n">user</span>        <span class="k">=</span> <span class="nc">AuthUser</span><span class="o">.</span><span class="n">buildFromSession</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="n">session</span><span class="o">).</span><span class="n">get</span>
    <span class="k">val</span> <span class="n">authHeaders</span> <span class="k">=</span> <span class="nc">ApiRequest</span><span class="o">.</span><span class="n">buildRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">authToken</span><span class="o">).</span><span class="n">buildHeaders</span><span class="o">.</span><span class="n">toMap</span>
    <span class="k">val</span> <span class="n">reqHeaders</span>  <span class="k">=</span> <span class="n">request</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">toSimpleMap</span>
    <span class="k">val</span> <span class="n">apiHeaders</span>  <span class="k">=</span> <span class="n">reqHeaders</span> <span class="o">++</span> <span class="n">authHeaders</span>
    <span class="k">var</span> <span class="n">url</span> <span class="k">=</span> <span class="nc">WS</span><span class="o">.</span><span class="n">url</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="nc">Global</span><span class="o">.</span><span class="nc">API_ENDPOINT</span> <span class="o">+</span> <span class="n">endpointPath</span><span class="o">)</span>
    <span class="n">apiHeaders</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">url</span> <span class="k">=</span> <span class="n">url</span><span class="o">.</span><span class="n">withHeaders</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">)</span>
    <span class="o">}}</span>

    <span class="c1">// Create promises for the iteratee over file data, and the result
</span>    <span class="k">val</span> <span class="n">iterateePromise</span> <span class="k">=</span> <span class="n">promise</span><span class="o">[</span><span class="kt">Iteratee</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]]</span>
    <span class="k">val</span> <span class="n">resultPromise</span> <span class="k">=</span> <span class="n">promise</span><span class="o">[</span><span class="kt">SimpleResult</span><span class="o">]</span>

    <span class="c1">// Make the download request to the API
</span>    <span class="k">val</span> <span class="n">req</span> <span class="k">=</span> <span class="n">url</span><span class="o">.</span><span class="n">get</span> <span class="o">{</span> <span class="n">responseHeaders</span><span class="k">:</span> <span class="kt">ResponseHeaders</span> <span class="o">=&gt;</span>
      <span class="c1">// Resolve the result promise using the response from the API
</span>      <span class="n">resultPromise</span><span class="o">.</span><span class="n">success</span><span class="o">(</span>
        <span class="nc">Ok</span><span class="o">.</span><span class="n">stream</span><span class="o">({</span><span class="n">content</span><span class="k">:</span> <span class="kt">Iteratee</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=&gt;</span>
          <span class="c1">// Resolve the iteratee promise with the client output iteratee
</span>          <span class="n">iterateePromise</span><span class="o">.</span><span class="n">success</span><span class="o">(</span><span class="n">content</span><span class="o">)</span>
        <span class="o">}).</span><span class="n">withHeaders</span><span class="o">(</span>
          <span class="s">"Content-Type"</span> <span class="o">-&gt;</span> <span class="n">responseHeaders</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"application/octet-stream"</span><span class="o">)).</span><span class="n">head</span><span class="o">,</span>
          <span class="s">"Connection"</span><span class="o">-&gt;</span><span class="s">"Close"</span><span class="o">,</span>
          <span class="s">"Transfer-Encoding"</span><span class="o">-&gt;</span> <span class="n">responseHeaders</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"Transfer-Encoding"</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"chunked"</span><span class="o">)).</span><span class="n">head</span>
        <span class="o">)</span>
      <span class="o">)</span>
      <span class="c1">// Run the iteratee for the response to the client
</span>      <span class="nc">Iteratee</span><span class="o">.</span><span class="n">flatten</span><span class="o">(</span><span class="n">iterateePromise</span><span class="o">.</span><span class="n">future</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">// Handle request completion by sending EOF to the client
</span>    <span class="n">req</span><span class="o">.</span><span class="n">onSuccess</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">ii</span> <span class="k">=&gt;</span> <span class="n">ii</span><span class="o">.</span><span class="n">feed</span><span class="o">(</span><span class="nc">Input</span><span class="o">.</span><span class="nc">EOF</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">// Handle request failure
</span>    <span class="n">req</span><span class="o">.</span><span class="n">recover</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="o">{</span>
        <span class="n">resultPromise</span><span class="o">.</span><span class="n">tryFailure</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// Return control back to Play for handling
</span>    <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">resultPromise</span><span class="o">.</span><span class="n">future</span><span class="o">,</span> <span class="mi">30</span> <span class="n">seconds</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div>

<p>It’s a bit hard to follow with all the promises, futures, iteratees, etc - but the gist is that as soon as we get response headers from the API, we’ll send those to the client, with status code 200, specifying a chunked transfer encoding, as well as the content type for the response body. As the response body from the API begins to download, it will pipe the chunked data straight into the response to the client. Unfortunately, it’s not very intuitive code to read, and this section of code is the one that has me constantly double checking my work to make sure I didn’t mess something up - it just doesn’t read as naturally as I would like.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>I have some ideas around how this might be improved. For one, I feel like it should be possible to extract the proxied request logic from the web server’s StreamingBodyParser into an implementation of StorageProvider, and thereby use a single StreamingBodyParser implementation. I haven’t dug in to that to see what the gotchas might be though. I haven’t done any performance benchmarks, but in my testing it seemed like uploads and downloads were snappy. Overall I feel like it’s a fairly solid solution, but I’m waiting to see where it breaks once heavy load becomes more of a concern.</p>

<p>If you have improvements, thoughts, whatever, please leave a comment!</p>

</article>









      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
        Paul Schoenfelder (<a href="https://github.com/bitwalker">bitwalker</a>) (<a href="https://twitter.com/gotbones">@gotbones</a>)
    </small>
  </div>
</footer>

</body>
</html>
